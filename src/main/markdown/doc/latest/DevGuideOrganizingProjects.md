Organizing Projects
===

GWT projects can be organized in a variety of ways. However, particular conventions are encouraged to make it easy to identify which code is intended to run on the client
browser, the server, or both.

This section describes the fundamentals of project organization with GWT as well as the recommended conventions.

1.  [HTML Host Pages](#DevGuideHostPage)
2.  [Standard Directory and Package Layout](#DevGuideDirectoriesPackageConventions)
3.  [Modules: Units of configuration](#DevGuideModules)
4.  [Module XML files](#DevGuideModuleXml)
5.  [How do I know which GWT modules I need to inherit?](#DevGuideInheritingModules)
6.  [Automatic Resource Inclusion](#DevGuideAutomaticResourceInclusion)
7.  [Filtering Public and Source Packages](#DevGuidePathFiltering)
8.  [The Bootstrap Sequence](#DevGuideBootstrap)

## HTML Host Pages<a id="DevGuideHostPage"></a>

GWT modules are stored on a web server as a set of JavaScript and related files. In order to run the module, it must be loaded from a web page of some sort. Any HTML page can
include a GWT application via a <tt>SCRIPT</tt> tag. This HTML page is referred to as a _host page_ from the GWT application's point of view. A typical HTML host page for an
application written with GWT from scratch might not include any visible HTML body content at all. The example below shows how to embed a GWT application that will use the entire
browser window.

<pre class="prettyprint">
 &lt;html&gt;
  &lt;head&gt;
  
    &lt;!-- Properties can be specified to influence deferred binding --&gt;
    &lt;meta name='gwt:property' content='locale=en_UK'&gt;
    
    &lt;!-- Stylesheets are optional, but useful --&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;Calendar.css&quot;&gt;
    
    &lt;!-- Titles are optional, but useful --&gt;
    &lt;title&gt;Calendar App&lt;/title&gt;
    
  &lt;/head&gt;
  &lt;body&gt;
   
    &lt;!-- This script tag is what actually loads the GWT module.  The --&gt;
    &lt;!-- 'nocache.js' file (also called a &quot;selection script&quot;) is     --&gt;
    &lt;!-- produced by the GWT compiler in the module output directory --&gt;
    &lt;!-- or generated automatically in development mode.             --&gt;
    &lt;script language=&quot;javascript&quot; src=&quot;calendar/calendar.nocache.js&quot;&gt;&lt;/script&gt;
    
    &lt;!-- Include a history iframe to enable full GWT history support --&gt;
    &lt;!-- (the id must be exactly as shown)                           --&gt;
    &lt;iframe src=&quot;javascript:''&quot; id=&quot;__gwt_historyFrame&quot; style=&quot;width:0;height:0;border:0&quot;&gt;&lt;/iframe&gt;
    
  &lt;/body&gt;
 &lt;/html&gt;
</pre>

Note that the body of the page contains only a <tt>SCRIPT</tt> tag and an <tt>IFRAME</tt> tag. It is left to the GWT application to then fill in all the visual content.

But GWT was designed to make it easy to add GWT functionality to existing web applications with only minor changes. It is possible to allow the GWT module to selectively insert
widgets into specific places in an HTML page. To accomplish this, use the <tt>id</tt> attribute in your HTML tags to specify a unique identifier that your GWT code will use to
attach widgets to that HTML element. For example:

<pre class="prettyprint">
  &lt;body&gt;
    &lt;!-- ... other sample HTML omitted   --&gt;
    &lt;table align=center&gt;
      &lt;tr&gt;
        &lt;td id=&quot;slot1&quot;&gt;&lt;/td&gt;
        &lt;td id=&quot;slot2&quot;&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/body&gt;
</pre>

Notice that the <tt>td</tt> tags include an <tt>id</tt> attribute associated with them. This attribute is accessible through the <tt>DOM</tt> class. You can easily attach
widgets using the method <tt>RootPanel.get()</tt>. For example:

<pre class="prettyprint">
    final Button button = new Button(&quot;Click me&quot;);
    final Label label = new Label();

    ...

    RootPanel.get(&quot;slot1&quot;).add(button);
    RootPanel.get(&quot;slot2&quot;).add(label);
</pre>

In this manner, GWT functionality can be added as just a part of an existing page, and changing the application layout can be done in plain HTML. The <tt>I18N</tt> sample uses
this technique heavily.

A host HTML page does not have to be static content. It could also be generated by a servlet, or by a JSP page.

## Standard Directory and Package Layout<a id="DevGuideDirectoriesPackageConventions"></a>

GWT projects are overlaid onto Java packages such that most of the configuration can be inferred from the classpath and the [module definitions](DevGuideOrganizingProjects.html#DevGuideModules).

![](images/DevGuideDirectoriesPackageConventions.png)

### Guidelines

If you are not using the Command-line tools to generate your project files and directories, here are some guidelines to keep in mind when organizing your code and creating Java
packages.

1.  Under the main project directory create the following directories:
2.  *   src folder - contains production Java source
    *   war folder - your web app; contains static resources as well as compiled output
    *   test folder - (optional) JUnit test code would go here
3.  Within the src package, create a project root package and a client package.
4.  If you have server-side code, also create a server package to differentiate between the client-side code (which is translated into JavaScript) from the server-side code (which
is not).
5.  Within the project root package, place one or more module definitions.
6.  In the war directory, place any static resources (such as the host page, style sheets, or images).
7.  Within the client and server packages, you are free to organize your code into any subpackages you require.

### Example: GWT standard package layout

For example, all the files for the &quot;DynaTable&quot; sample are organized in a main project directory also called &quot;DynaTable&quot;.

*   Java source files are in the directory: <tt>DynaTable/src/com/google/gwt/sample/dynatable</tt>
*   The module is defined in the XML file: <tt>DynaTable/src/com/google/gwt/sample/dynatable/DynaTable.gwt.xml</tt>
*   The project root package is: <tt>com.google.gwt.sample.dynatable</tt>
*   The logical module name is: <tt>com.google.gwt.sample.dynatable.DynaTable</tt>

#### The src directory

The src directory contains an application's Java source files, the module definition, and external resource files.

<table>
<tr>
<th>Package</th>
<th>File</th>
<th>Purpose</th>
</tr>

<tr>
<td><tt>com.google.gwt.sample.dynatable</tt> </td>
<td/>
<td>The project root package contains module XML files.</td>
</tr>

<tr>
<td><tt>com.google.gwt.sample.dynatable</tt> </td>
<td><tt>DynaTable.gwt.xml</tt> </td>
<td>Your application module. Inherits <tt>com.google.gwt.user.User</tt> and adds an entry point class,
<tt>com.google.gwt.sample.dynatable.client.DynaTable</tt>.</td>
</tr>

<tr>
<td><tt>com.google.gwt.sample.dynatable.public</tt> </td>
<td/>
<td>Static resources that are loaded programmatically by GWT code. Files in the public directory are copied into the same directory
as the GWT compiler output.</td>
</tr>

<tr>
<td><tt>com.google.gwt.sample.dynatable.public</tt> </td>
<td><tt>logo.gif</tt> </td>
<td>An image file available to the application code. You might load this file programmatically using this URL:
<tt>GWT.getModuleBaseForStaticFiles() + &quot;logo.gif&quot;</tt>.</td>
</tr>

<tr>
<td><tt>com.google.gwt.sample.dynatable.client</tt> </td>
<td/>
<td>Client-side source files and subpackages.</td>
</tr>

<tr>
<td><tt>com.google.gwt.sample.dynatable.client</tt> </td>
<td><tt>DynaTable.java</tt> </td>
<td>Client-side Java source for the entry-point class.</td>
</tr>

<tr>
<td><tt>com.google.gwt.sample.dynatable.client</tt> </td>
<td><tt>SchoolCalendarService.java</tt> </td>
<td>An RPC service interface.</td>
</tr>

<tr>
<td><tt>com.google.gwt.sample.dynatable.server</tt> </td>
<td/>
<td>Server-side code and subpackages.</td>
</tr>

<tr>
<td><tt>com.google.gwt.sample.dynatable.server</tt> </td>
<td><tt>SchoolCalendarServiceImpl.java</tt> </td>
<td>Server-side Java source that implements the logic of the service.</td>
</tr>
</table>

#### The war directory

The war directory is the deployment image of your web application. It is in the standard expanded war format recognized by a variety of Java web servers, including Tomcat,
Jetty, and other J2EE servlet containers. It contains a variety of resources:

*   Static content you provide, such as the host HTML page
*   GWT compiled output
*   Java class files and jar files for server-side code
*   A web.xml file that configures your web app and any servlets

A detailed description of the war format is beyond the scope of this document, but here are the basic pieces you will want to know about:

<table>
<tr>
<th>Directory</th>
<th>File</th>
<th>Purpose</th>
</tr>

<tr>
<td><nobr><tt>DynaTable/war/</tt></nobr></td>
<td><tt>DynaTable.html</tt></td>
<td>A host HTML page that loads the DynaTable app.</td>
</tr>

<tr>
<td><nobr><tt>DynaTable/war/</tt></nobr></td>
<td><tt>DynaTable.css</tt></td>
<td>A static style sheet that styles the DynaTable app.</td>
</tr>

<tr>
<td><nobr><tt>DynaTable/war/dynatable/</tt></nobr></td>
<td/>
<td>The DynaTable module directory where the GWT compiler writes output and files on the public path are copied. NOTE: by default
this directory would be the long, fully-qualified module name <tt>com.google.gwt.sample.dynatable.DynaTable</tt>. However, in our GWT module XML file we used the
<tt>rename-to=&quot;dynatable&quot;</tt> attribute to shorten it to a nice name.</td>
</tr>

<tr>
<td><nobr><tt>DynaTable/war/dynatable/</tt></nobr></td>
<td><tt>dynatable.nocache.js</tt> </td>
<td>The &quot;selection script&quot; for DynaTable. This is the script that must be loaded from the host HTMLto load the GWT module into the
page.</td>
</tr>

<tr>
<td><nobr><tt>DynaTable/war/WEB-INF</tt></nobr></td>
<td/>
<td>All non-public resources live here, see the servlet specification for more detail.</td>
</tr>

<tr>
<td><nobr><tt>DynaTable/war/WEB-INF</tt></nobr></td>
<td><tt>web.xml</tt> </td>
<td>Configures your web app and any servlets.</td>
</tr>

<tr>
<td><nobr><tt>DynaTable/war/WEB-INF/classes</tt></nobr></td>
<td/>
<td>Java compiled class files live here to implement server-side functionality. If you're using an IDE set the output directory to
this folder.</td>
</tr>

<tr>
<td><nobr><tt>DynaTable/war/WEB-INF/lib</tt></nobr></td>
<td/>
<td>Any library dependencies your server code needs goes here.</td>
</tr>

<tr>
<td><nobr><tt>DynaTable/war/WEB-INF/lib</tt></nobr></td>
<td><tt>gwt-servlet.jar</tt> </td>
<td>If you have any servlets using GWT RPC, you will need to place a copy of <tt>gwt-servlet.jar</tt> here.</td>
</tr>
</table>

#### The test directory

The test directory contains the source files for any JUnit tests.

<table>
<tr>
<th>Package</th>
<th>File</th>
<th>Purpose</th>
</tr>

<tr>
<td><tt>com.google.gwt.sample.dynatable.client</tt> </td>
<td/>
<td>Client-side test files and subpackages.</td>
</tr>

<tr>
<td><tt>com.google.gwt.sample.dynatable.client</tt> </td>
<td><tt>DynaTableTest.java</tt> </td>
<td>Test cases for the entry-point class.</td>
</tr>

<tr>
<td><tt>com.google.gwt.sample.dynatable.server</tt> </td>
<td/>
<td>Server-side test files and subpackages.</td>
</tr>

<tr>
<td><tt>com.google.gwt.sample.dynatable.server</tt> </td>
<td><tt>SchoolCalendarServiceImplTest.java</tt> </td>
<td>Test cases for server classes.</td>
</tr>
</table>

## Modules: Units of configuration<a id="DevGuideModules"></a>

Individual units of GWT configuration are called _modules_. A module bundles together all the configuration settings that your GWT project needs:

*   inherited modules
*   an entry point application class name; these are optional, although any module referred to in HTML must have at least one entry-point class specified
*   source path entries
*   public path entries
*   deferred binding rules, including property providers and class generators

Modules are [defined in XML](DevGuideOrganizingProjects.html#DevGuideModuleXml) and placed into your [project's package hierarchy](DevGuideOrganizingProjects.html#DevGuideDirectoriesPackageConventions). Modules may appear in any package in your classpath, although it is strongly
recommended that they appear in the root package of a [standard project layout](DevGuideOrganizingProjects.html#DevGuideDirectoriesPackageConventions).

### Entry-Point Classes

A module entry-point is any class that is assignable to [EntryPoint](/javadoc/latest/com/google/gwt/core/client/EntryPoint.html) and that can be constructed without parameters. When a module is loaded, every entry point class is instantiated and its [EntryPoint.onModuleLoad()](/javadoc/latest/com/google/gwt/core/client/EntryPoint.html#onModuleLoad()) method gets
called.

### Source Path

Modules can specify which subpackages contain translatable _source_, causing the named package and its subpackages to be added to the _source path_. Only files found
on the source path are candidates to be translated into JavaScript, making it possible to mix [client-side](DevGuideCodingBasics.html#DevGuideClientSide) and [server-side](DevGuideServerCommunication.html#DevGuideServerSide) code together in the same classpath without conflict. When module inherit other modules, their source paths are
combined so that each module will have access to the translatable source it requires.

The default source path is the _client_ subpackage underneath where the [Module XML File](DevGuideOrganizingProjects.html#DevGuideModuleXml) is stored.

### Public Path

Modules can specify which subpackages are _public_, causing the named package and its subpackages to be added to the _public path_. The public path is the place in
your project where static resources referenced by your GWT module, such as CSS or images, are stored. When you compile your application into JavaScript, all the files that can be
found on your public path are copied to the module's output directory. When referencing public resources in client code (for example, setting the URL of an <tt>Image</tt> widget,
you should construct the URL like this: <tt>GWT.getModuleBaseForStaticFiles() + &quot;resourceName.png&quot;</tt>. When referencing public resources from a [Module XML File](DevGuideOrganizingProjects.html#DevGuideModuleXml), just use the relative path within the public folder, the module's base URL will be prepended automatically.
When a module inherits other modules, their public paths are combined so that each module will have access to the static resources it expects.

The default public path is the _public_ subdirectory underneath where the [Module XML File](DevGuideOrganizingProjects.html#DevGuideModuleXml) is stored.

## Defining a module: format of module XML files<a id="DevGuideModuleXml"></a>

Modules are defined in XML files with a file extension of _.gwt.xml_. Module XML files should reside in your project's root package.

If you are using the [standard project structure](DevGuideOrganizingProjects.html#DevGuideDirectoriesPackageConventions), your module XML can be as simple as the following
example:

<pre class="prettyprint">
 &lt;module rename-to=&quot;dynatable&quot;&gt;
    &lt;inherits name=&quot;com.google.gwt.user.User&quot; /&gt;
    &lt;entry-point class=&quot;com.google.gwt.sample.dynatable.client.DynaTable&quot; /&gt;
 &lt;/module&gt;
</pre>

### Loading modules

Module XML files are found on the Java classpath. Modules are always referred to by their logical names. The logical name of a module is of the form _pkg1.pkg2.ModuleName_
(although any number of packages may be present). The logical name includes neither the actual file system path nor the file extension.

For example, if the module XML file has a file name of...

<pre>
~/src/com/example/cal/Calendar.gwt.xml
</pre>

...then the logical name of the module is:

<pre>
com.example.cal.Calendar
</pre>

### Renaming modules

The <tt>&lt;module&gt;</tt> element supports an optional attribute <tt>rename-to</tt> that causes the compiler to behave as though the module had a different name than the
long, fully-qualified name. Renaming a module has two primary use cases:

*   to have a shorter module name that doesn't reflect the actual package structure, this is the most typical and recommended use case
*   to create a &quot;working module&quot; to speed up development time by restricting the number of permutations

<tt>com.foo.WorkingModule.gwt.xml</tt>:

<pre class="prettyprint">
&lt;module rename-to=&quot;com.foo.MyModule&quot;&gt;
  &lt;inherits name=&quot;com.foo.MyModule&quot; /&gt;
  &lt;set-property name=&quot;user.agent&quot; value=&quot;ie6&quot; /&gt;
  &lt;set-property name=&quot;locale&quot; value=&quot;default&quot; /&gt;
&lt;/module&gt;
</pre>

When <tt>WorkingModule.gwt.xml</tt> is compiled, the compiler will produce only an <tt>ie6</tt> variant using the default locale; this will speed up development compilations.
The output from the <tt>WorkingModule.gwt.xml</tt> will be a drop-in replacement for <tt>MyModule.gwt.xml</tt> because the compiler will generate the output using the alternate
name. (Of course, if <tt>com.foo.MyModule</tt> was itself renamed, you would just copy its rename-to attribute.)

### Dividing code into multiple modules

Creating a second module doesn't necessarily mean that that module must define an entry point. Typically, you create a new module when you want to package up a library of GWT
code that you want to reuse in other GWT projects. An example of this is the Google API Library for GWT ([GALGWT](http://code.google.com/p/gwt-google-apis/)), specifically the Gears for GWT API binding. If you download the library and take a look at the <tt>gwt-google-apis/com/google/gwt/gears</tt> you'll
find the <tt>Gears.gwt.xml</tt> file for the module which doesn't define an entry point. However, any GWT project that would like to use Gears for GWT will have to inherit the
Gears.gwt.xml module. For example, a module named &quot;Foo&quot; might want to use GALGWT, so in <tt>Foo.gwt.xml</tt> an <tt>&lt;inherits&gt;</tt> entry would be needed:

<pre class="prettyprint">
&lt;module&gt;
...
    &lt;inherits name='com.google.gwt.gears.Gears' /&gt;
</pre>

### Loading multiple modules in an HTML host page

If you have multiple GWT modules in your application, there are two ways to approach loading them.

1.  Compile each module separately and include each module with a separate <tt>&lt;script&gt;</tt> tag in your [HTML host
page](DevGuideOrganizingProjects.html#DevGuideHostPage).
2.  Create a top level module XML definition that includes all the modules you want to include. Compile the top level module to create a single set of JavaScript output.

The first approach may seem the easiest and most obvious. However, the second approach will lead to much better end-user performance. The problem with loading multiple modules
is that each module has to be downloaded separately by the end-user's browser. In addition, each module will contain redundant copies of GWT library code and could possibly
conflict with each other during event handling. The second approach is strongly recommended.

### Controlling compiler output

The GWT compiler separates the act of compiling and packaging its output with the Linker subsystem. It is responsible for the final packaging of the JavaScript code and
providing a pluggable bootstrap mechanism for any particular deployment scenario.

*   <tt>&lt;</tt>define-linker name=&quot;_short_name_&quot; class=&quot;_fully_qualified_class_name_&quot; /<tt>&gt;</tt> : Register a new Linker instance with the compiler. The
<tt>name</tt> attribute must be a valid Java identifier and is used to identify the Linker in <tt>&lt;add-linker&gt;</tt> tags. It is permissible to redefine an already-defined
Linker by declaring a new <tt>&lt;define-linker&gt;</tt> tag with the same name. Linkers are divided into three categories, PRE, POST, and PRIMARY. Exactly one primary linker is
run for a compilation. Pre-linkers are run in lexical order before the primary linker, and post-linkers are run in reverse lexical order after the primary linker.
*   <tt>&lt;</tt>add-linker name=&quot;_linker_name_&quot; /<tt>&gt;</tt> : Specify a Linker to use when generating the output from the compiler. The <tt>name</tt> property is a
previously-defined Linker name. This tag is additive for pre- and post-linkers; only the last primary linker will be run.

Several linkers are provided by <tt>Core.gwt.xml</tt>, which is automatically inherited by <tt>User.gwt.xml</tt>.

*   **std** : The standard iframe-based bootstrap deployment model.
*   **xs** : The cross-site deployment model.
*   **sso** : This Linker will produce a monolithic JavaScript file. It may be used only when there is a single distinct compilation result.

From <tt>Core.gwt.xml</tt>:

<pre class="prettyprint">
&lt;module&gt;
   &lt;define-linker name=&quot;std&quot; class=&quot;com.google.gwt.dev.linker.IFrameLinker&quot; /&gt;
   &lt;define-linker name=&quot;sso&quot; class=&quot;com.google.gwt.dev.linker.SingleScriptLinker&quot; /&gt;
   &lt;define-linker name=&quot;xs&quot; class=&quot;com.google.gwt.dev.linker.XSLinker&quot; /&gt;
   &lt;add-linker name=&quot;std&quot; /&gt;
&lt;/module&gt;
</pre>

Changing the desired linker in <tt>MyModule.gwt.xml</tt>:

<pre class="prettyprint">
&lt;module&gt;
  &lt;inherits name=&quot;com.google.gwt.core.Core&quot; /&gt;
  &lt;add-linker name=&quot;xs&quot; /&gt;
&lt;/module&gt;
</pre>

### Overriding one package implementation with another

The <tt>&lt;super-source&gt;</tt> tag instructs the compiler to &quot;re-root&quot; a source path. This is useful for cases where you want to be re-use an existing Java API for a GWT
project, but the original source is not available or not translatable. A common reason for this is to emulate part of the JRE not implemented by GWT.

For example, suppose you want implement the UUID class provided by the JRE under <tt>java.util</tt>. Assume your project's module file is
<tt>com/example/myproject/MyProject.gwt.xml</tt>. Place the source for the UUID class into <tt>com/example/myproject/jre/java/util/UUID.java</tt>. Then add a line to
<tt>MyProject.gwt.xml</tt>:

<pre class="prettyprint">
    &lt;super-source path=&quot;jre&quot; /&gt;
</pre>

This tells the compiler to add all subfolders of <tt>com/example/myproject/jre/</tt> to the [source path](DevGuideOrganizingProjects.html#DevGuideModules), but to strip off
the path prefix up to and including <tt>jre</tt>. As a result, <tt>com/google/myproject/gwt/jre/java/util/UUID.java</tt> will be visible to the compiler as
<tt>java/util/UUID.java</tt>, which is the intended result.

The GWT project uses this technique internally for the JRE emulation
classes provided with GWT. One caveat specific to overriding JRE classes in
this way is that they will never actually be used in development mode. In
development mode, the native JRE classes always supercede classes compiled
from source.

The <tt>&lt;super-source&gt;</tt> element supports [pattern-based
filtering](DevGuideOrganizingProjects.html#DevGuidePathFiltering) to allow fine-grained control over which resources get copied
into the output directory during a GWT compile.

### XML Element Reference

This section documents the most commonly used elements in the module XML file.

*   <tt>&lt;</tt>inherits name=&quot;_logical-module-name_&quot; /<tt>&gt;</tt> : Inherits all the settings from the specified module as if the contents of the inherited module's XML
were copied verbatim. Any number of modules can be inherited in this manner. See also [this advice about deciding which modules to inherit](DevGuideOrganizingProjects.html#DevGuideInheritingModules).

*   <tt>&lt;</tt>entry-point class=&quot;_classname_&quot; /<tt>&gt;</tt> : Specifies an [entry point](/javadoc/latest/com/google/gwt/core/client/EntryPoint.html) class. Any number of entry-point classes
can be added, including those from inherited modules. Entry points are all compiled into a single codebase. They are called sequentially in the order in which they appear in the
module file. So when the <tt>onModuleLoad()</tt> of your first entry point finishes, the next entry point is called immediately.

*   <tt>&lt;</tt>source path=&quot;_path_&quot; /<tt>&gt;</tt> : Each occurrence of the <tt>&lt;source&gt;</tt> tag adds a package to the [source path](DevGuideOrganizingProjects.html#DevGuideModules) by combining the package in which the module XML is found with the specified path to a subpackage. Any Java source
file appearing in this subpackage or any of its subpackages is assumed to be translatable. The <tt>&lt;source&gt;</tt> element supports [pattern-based filtering](DevGuideOrganizingProjects.html#DevGuidePathFiltering) to allow fine-grained control over which resources get copied into the output directory
during a GWT compile.

> If no <tt>&lt;source&gt;</tt> element is defined in a module XML file, the _client_ subpackage is implicitly added to the source path as if <tt>&lt;source
> path=&quot;client&quot; /&gt;</tt> had been found in the XML. This default helps keep module XML compact for standard project layouts.

*   <tt>&lt;</tt>public path=&quot;_path_&quot; /<tt>&gt;</tt> : Each occurrence of the <tt>&lt;public&gt;</tt> tag adds a package to the [public path](DevGuideOrganizingProjects.html#DevGuideModules) by combining the package in which the module XML is found with the specified path to identify the root of a public
path entry. Any file appearing in this package or any of its subpackages will be treated as a publicly-accessible resource. The <tt>&lt;public&gt;</tt> element supports [pattern-based filtering](DevGuideOrganizingProjects.html#DevGuidePathFiltering) to allow fine-grained control over which resources get copied into the output directory
during a GWT compile.

> If no <tt>&lt;public&gt;</tt> element is defined in a module XML file, the _public_ subpackage is implicitly added to the public path as if <tt>&lt;public
> path=&quot;public&quot;&gt;</tt> had been found in the XML. This default helps keep module XML compact for standard project layouts.

*   <tt>&lt;</tt>servlet path=&quot;_url-path_&quot; class=&quot;_classname_&quot; /<tt>&gt;</tt> : For RPC, this element loads a servlet class mounted at the specified URL path. The URL
path should be absolute and have the form of a directory (for example, <tt>/calendar</tt>). Your client code then specifies this URL mapping by annotating the service interface
with the [@RemoteServiceRelativePath](/javadoc/latest/com/google/gwt/user/client/rpc/RemoteServiceRelativePath.html) attribute. Any number of servlets may be loaded in this manner, including those from inherited modules.

> The <tt>&lt;servlet&gt;</tt> element applies only to GWT's embedded server server-side debugging feature.

> _NOTE: as of GWT 1.6, this tag does no longer loads servlets in
> development mode, instead you must configure a <tt>WEB-INF/web.xml</tt> in
> your war directory to load any servlets needed._

*   <tt>&lt;</tt>script src=&quot;_js-url_&quot; /<tt>&gt;</tt> : Automatically injects the external JavaScript file located at the location specified by _src_. See [automatic resource inclusion](DevGuideOrganizingProjects.html#DevGuideAutomaticResourceInclusion) for details. If the specified URL is not absolute, the resource will be loaded
from the module's base URL (in other words, it would most likely be a public resource).

*   <tt>&lt;</tt>stylesheet src=&quot;_css-url_&quot; /<tt>&gt;</tt> : Automatically injects the external CSS file located at the location specified by _src_. See [automatic resource inclusion](DevGuideOrganizingProjects.html#DevGuideAutomaticResourceInclusion) for details. If the specified URL is not absolute, the resource will be loaded
from the module's base URL (in other words, it would most likely be a public resource).

*   <tt>&lt;</tt>extend-property name=&quot;_client-property-name_&quot; values=&quot;_comma-separated-values_&quot; /<tt>&gt;</tt> : Extends the set of values for an existing client
property. Any number of values may be added in this manner, and client property values accumulate through inherited modules. You will likely only find this useful for [specifying locales in internationalization](DevGuideI18nLocale.html#LocaleSpecifying).

### Elements for Deferred Binding

The following elements are used for defining [deferred binding](DevGuideCodingBasics.html#DevGuideDeferredBinding) rules. Deferred binding is not commonly used in user
projects.

*   <tt>&lt;</tt>replace-with class=&quot;_replacement_class_name_&quot;<tt>&gt;</tt> : A directive to use deferred binding with replacement.

*   <tt>&lt;</tt>generate-with class=&quot;_generator_class_name_&quot;<tt>&gt;</tt> : A directive to use deferred binding using a [Generator](/javadoc/latest/com/google/gwt/core/ext/Generator.html)

*   <tt>&lt;</tt>define-property name=&quot;_property_name_&quot; values=&quot;_property_values_&quot;<tt>&gt;</tt> : Define a property and allowable values (comma-separated identifiers).
This element is typically used to generate a value that will be evaluated by a rule using a <tt>&lt;when...&gt;</tt> element.

*   <tt>&lt;</tt>set-property name=&quot;_property_name_&quot; value=&quot;_property_value_&quot;<tt>&gt;</tt> : Set the value of a previously-defined property (see <tt>&lt;define
property&gt;</tt> above). This element is typically used to generate a value that will be evaluated by a rule using a <tt>&lt;when...&gt;</tt> element. Note that
<tt>set-property</tt> and <tt>property-provider</tt> on the same value will overwrite each other. The last definition encountered is the one that is used.

*   <tt>&lt;</tt>property-provider name=&quot;_property_name_&quot;<tt>&gt;</tt> : Define a JavaScript fragment that will return the value for the named property at runtime. This
element is typically used to generate a value that will be evaluated in a <tt>&lt;when...&gt;</tt> element. To see examples of <tt>&lt;property-provider&gt;</tt> definitions in
action, see the files <tt>I18N.gwt.xml</tt> and <tt>UserAgent.gwt.xml</tt> in the GWT source code. Note that <tt>set-property</tt> and <tt>property-provider</tt> on the same value
will overwrite each other. The last definition encountered is the one that is used.

#### Defining conditions

The <tt>&lt;replace-with-class&gt;</tt> and <tt>&lt;generate-with-class&gt;</tt> elements can take a <tt>&lt;when...&gt;</tt> child element that defines when this rule should
be used, much like the <tt>WHERE</tt> predicate of an SQL query. The three different types of predicates are:

*   <tt>&lt;</tt>when-property-is name=&quot;_property_name_&quot; value=&quot;_value_&quot; /<tt>&gt;</tt> : Deferred binding predicate that is true when a named property has a given
value.

*   <tt>&lt;</tt>when-type-assignable class=&quot;_class_name_&quot; /<tt>&gt;</tt> : Deferred binding predicate that is true for types in the type system that are assignable to the
specified type.

*   <tt>&lt;</tt>when-type-is class=&quot;_class_name_&quot; /<tt>&gt;</tt> : Deferred binding predicate that is true for exactly one type in the type system.

Several different predicates can be combined into an expression. Surround your <tt>&lt;when...&gt;</tt> elements using the following nesting elements begin/end tags:

*   <tt>&lt;all&gt;</tt> _when_expressions_ <tt>&lt;/all&gt;</tt> : Predicate that ANDs all child conditions.

*   <tt>&lt;any&gt;</tt> _when_expressions_ <tt>&lt;/any&gt;</tt> : Predicate that ORs all child conditions.

*   <tt>&lt;none&gt;</tt> _when_expressions_ <tt>&lt;/none&gt;</tt> : Predicate that NANDs all child conditions.

#### Deferred Binding Example

As an example module XML file that makes use of deferred binding rules, here is a module XML file from the GWT source code, Focus.gwt.xml:

<pre class="prettyprint">
&lt;module&gt;
  &lt;inherits name=&quot;com.google.gwt.core.Core&quot; /&gt;
  &lt;inherits name=&quot;com.google.gwt.user.UserAgent&quot; /&gt;

  &lt;!-- old Mozilla, and Opera need a different implementation --&gt;
  &lt;replace-with class=&quot;com.google.gwt.user.client.ui.impl.FocusImplOld&quot;&gt;
    &lt;when-type-is class=&quot;com.google.gwt.user.client.ui.impl.FocusImpl&quot; /&gt;
      &lt;any&gt;
        &lt;when-property-is name=&quot;user.agent&quot; value=&quot;gecko&quot; /&gt;
        &lt;when-property-is name=&quot;user.agent&quot; value=&quot;opera&quot; /&gt;
      &lt;/any&gt;
  &lt;/replace-with&gt;

  &lt;!--  Safari needs a different hidden input --&gt;
  &lt;replace-with class=&quot;com.google.gwt.user.client.ui.impl.FocusImplSafari&quot;&gt;
    &lt;when-type-is class=&quot;com.google.gwt.user.client.ui.impl.FocusImpl&quot; /&gt;
    &lt;when-property-is name=&quot;user.agent&quot; value=&quot;safari&quot; /&gt;
  &lt;/replace-with&gt;

  &lt;!-- IE's implementation traps exceptions on invalid setFocus() --&gt;
  &lt;replace-with class=&quot;com.google.gwt.user.client.ui.impl.FocusImplIE6&quot;&gt;
  &lt;when-type-is class=&quot;com.google.gwt.user.client.ui.impl.FocusImpl&quot; /&gt;
    &lt;any&gt;
      &lt;when-property-is name=&quot;user.agent&quot; value=&quot;ie6&quot; /&gt;
    &lt;/any&gt;
  &lt;/replace-with&gt;
&lt;/module&gt;
</pre>

## How do I know which GWT modules I need to inherit?<a id="DevGuideInheritingModules"></a>

GWT libraries are organized into modules. The standard modules contain big pieces of functionality designed to work independently of each other. By selecting only the modules
you need for your project (for example the JSON module rather than the XML module), you minimize complexity and reduce compilation time.

Generally, you want to inherit at least the User module. The User module contains all the core GWT functionality, including the EntryPoint class. The User module also contains
reusable UI components (widgets and panels) and support for the History feature, Internationalization, DOM programming, and more.

### Standard Modules GWT 1.5

<table>
<tr>
<td><strong>Module</strong> </td>
<td><strong>Logical Name</strong> </td>
<td><strong>Module Definition</strong> </td>
<td><strong>Contents</strong> </td>
</tr>

<tr>
<td>User</td>
<td>com.google.gwt.user.User</td>
<td>User.gwt.xml</td>
<td>Core GWT functionality</td>
</tr>

<tr>
<td>HTTP</td>
<td>com.google.gwt.http.HTTP</td>
<td>HTTP.gwt.xml</td>
<td>Low-level HTTP communications library</td>
</tr>

<tr>
<td>JSON</td>
<td>com.google.gwt.json.JSON</td>
<td>JSON.gwt.xml</td>
<td>JSON creation and parsing</td>
</tr>

<tr>
<td>JUnit</td>
<td>com.google.gwt.junit.JUnit</td>
<td>JUnit.gwt.xml</td>
<td>JUnit testing framework integration</td>
</tr>

<tr>
<td>XML</td>
<td>com.google.gwt.xml.XML</td>
<td>XML.gwt.xml</td>
<td>XML document creation and parsing</td>
</tr>
</table>

GWT 1.5 also provides several _theme_ modules which contain default styles for widgets and panels. You can specify one theme in your project's module XML file to use as a
starting point for styling your application, but you are not required to use any of them.

### Themes

<table>
<tr>
<td><strong>Module</strong> </td>
<td><strong>Logical Name</strong> </td>
<td><strong>Module Definition</strong> </td>
<td><strong>Contents</strong> </td>
</tr>

<tr>
<td>Chrome</td>
<td>com.google.gwt.user.theme.chrome.Chrome</td>
<td>Chrome.gwt.xml</td>
<td>Style sheet and images for the Chrome theme.</td>
</tr>

<tr>
<td>Dark</td>
<td>com.google.gwt.user.theme.dark.Dark</td>
<td>Dark.gwt.xml</td>
<td>Style sheet and images for the Dark theme.</td>
</tr>

<tr>
<td>Standard</td>
<td>com.google.gwt.user.theme.standard.Standard</td>
<td>Standard.gwt.xml</td>
<td>Style sheet and images for the Standard theme.</td>
</tr>
</table>

### How To

To inherit a module, edit your project's module XML file and specify the logical name of the module you want to inherit in the <tt>&lt;</tt>inherits<tt>&gt;</tt> tag.

<pre class="prettyprint">
  &lt;inherits name=&quot;com.google.gwt.junit.JUnit&quot;/&gt;
</pre>

**Note:** Modules are always referred to by their logical names. The logical name of a module is of the form _pkg1.pkg2.ModuleName_ (although any number of
packages may be present). The logical name includes neither the actual file system path nor the file extension.

## Automatic Resource Inclusion<a id="DevGuideAutomaticResourceInclusion"></a>

Modules can contain references to external JavaScript and CSS files, causing them to be automatically loaded when the module itself is loaded. This can be handy if your module
is intended to be used as a reusable component because your module will not have to rely on the HTML host page to specify an external JavaScript file or stylesheet.

### Including External JavaScript

Script inclusion is a convenient way to automatically associate external JavaScript files with your module. Use the following syntax to cause an external JavaScript file to be
loaded into the [host page](DevGuideOrganizingProjects.html#DevGuideHostPage) before your module entry point is called.

<pre class="prettyprint">
&lt;script src=&quot;_js-url_&quot;/&gt;
</pre>

The script is loaded into the namespace of the [host page](DevGuideOrganizingProjects.html#DevGuideHostPage) as if you had included it explicitly using the HTML
<tt>&lt;script&gt;</tt> element. The script will be loaded before your [onModuleLoad()](/javadoc/latest/com/google/gwt/core/client/EntryPoint.html#onModuleLoad()) is called.

> _Versions of GWT prior to 1.4 required a script-ready function to determine when an included script was loaded. This is no longer required; all included scripts will
> be loaded when your application starts, in the order in which they are declared._

### Including External Stylesheets

Stylesheet inclusion is a convenient way to automatically associate external CSS files with your module. Use the following syntax to cause a CSS file to be automatically
attached to the [host page](DevGuideOrganizingProjects.html#DevGuideHostPage).

<pre class="prettyprint">
&lt;stylesheet src=&quot;_css-url_&quot;/&gt;
</pre>

You can add any number of stylesheets this way, and the order of inclusion into the page reflects the order in which the elements appear in your module XML.

### Relative vs. Absolute URL

If an absolute URL is specified in the <tt>src</tt> attribute, that URL will be used verbatim. However, if a non-absolute URL is used (for example, &quot;foo.css&quot;), the module's
base URL is prepended to the resource name. This is identical to constructing an absolute URL using <tt>GWT.getModuleBaseForStaticFiles() + &quot;foo.css&quot;</tt> in client code. This is useful when
the target resource is from the module's public path.

### Inclusion and Module Inheritance

Module inheritance makes resource inclusion particularly convenient. If you wish to create a reusable library that relies upon particular stylesheets or JavaScript files, you
can be sure that clients of your library have everything they need automatically by inheriting from your module.

#### See Also

*   [Module XML Format](DevGuideOrganizingProjects.html#DevGuideModuleXml)

## Filtering Public and Source Packages<a id="DevGuidePathFiltering"></a>

The [module XML format's](DevGuideOrganizingProjects.html#DevGuideModuleXml) <tt>&lt;public&gt;</tt>, <tt>&lt;source&gt;</tt> and <tt>&lt;super-source&gt;</tt> elements
supports certain attributes and nested elements to allow pattern-based inclusion and exclusion in the [public path](DevGuideOrganizingProjects.html#DevGuideModules). These
elements follow the same rules as [Ant](http://ant.apache.org/)'s <tt>FileSet</tt> element. Please see the [documentation](http://ant.apache.org/manual/Types/fileset.html) for <tt>FileSet</tt> for a general overview. These elements do not support the full
<tt>FileSet</tt> semantics. Only the following attributes and nested elements are currently supported:

*   The <tt>includes</tt> attribute
*   The <tt>excludes</tt> attribute
*   The <tt>defaultexcludes</tt> attribute
*   The <tt>casesensitive</tt> attribute
*   Nested <tt>include</tt> tags
*   Nested <tt>exclude</tt> tags

Other attributes and nested elements are not supported.

#### Important

The default value of <tt>defaultexcludes</tt> is <tt>true</tt>. By default, the patterns listed [here](http://ant.apache.org/manual/dirtasks.html#defaultexcludes) are excluded.

## The Bootstrap Sequence<a id="DevGuideBootstrap"></a>

Consider the following HTML page that loads a GWT module:

<pre class="prettyprint">
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html&gt;
  &lt;body onload='alert(&quot;w00t!&quot;)'&gt;
    &lt;img src='bigImageZero.jpg'&gt;&lt;/img&gt;
    &lt;script source='externalScriptZero.js'&gt;&lt;/script&gt;
    &lt;img src='bigImageOne.jpg'&gt;&lt;/img&gt;
    &lt;img src='reallyBigImageTwo.jpg'&gt;&lt;/img&gt;
    &lt;script src='myApp/myApp.nocache.js'&gt;&lt;/script&gt;
    &lt;script src='externalScriptOne.js'&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

The following principles are needed to understand the sequence of operations that will occur in this page:

*   <tt>&lt;script&gt;</tt> tags always block evaluation of the page until the script is fetched and evaluated.
*   <tt>&lt;img&gt;</tt> tags do **not** block page evaluation.
*   Most browsers will allow a maximum of two simultaneous connections for fetching resources.
*   The <tt>body.onload()</tt> event will only fire once **all** external resources are fetched, including images and frames.
*   The GWT selection script (i.e. <tt>myApp/myApp.nocache.js</tt>) will be fetched and evaluated like a normal script tag, but the compiled script will be fetched
**asynchronously**.
*   Once the GWT selection script has started, its <tt>onModuleLoad()</tt> can be called at any point after the outer document has been parsed.

Applying these principles to the above example, we obtain the following sequence:

1.  The HTML document is fetched and parsing begins.
2.  Begin fetching <tt>bigImageZero.jpg</tt>.
3.  Begin fetching <tt>externalScriptZero.js</tt>.
4.  <tt>bigImageZero.jpg</tt> completes (let's assume). Parsing is blocked until <tt>externalScriptZero.js</tt> is done fetching and evaluating.
5.  <tt>externalScriptZero.js</tt> completes.
6.  Begin fetching <tt>bigImageOne.jpg</tt> and <tt>reallyBigImageTwo.jpg</tt> simultaneously.
7.  <tt>bigImageOne.jpg</tt> completes (let's assume again). <tt>myApp/myApp.nocache.js</tt> begins fetching and evaluating.
8.  <tt>myApp/myApp.nocache.js</tt> completes, and the compiled script (<tt>&lt;hashname&gt;.cache.html</tt>) begins fetching in a hidden <tt>IFRAME</tt> (this is non-blocking).
9.  <tt>&lt;hashname&gt;.cache.html</tt> completes. <tt>onModuleLoad()</tt> is not called yet, as we're still waiting on <tt>externalScriptOne.js</tt> to complete before the document is considered 'ready'.
10.  <tt>externalScriptOne.js</tt> completes. The document is ready, so onModuleLoad() fires.
11.  <tt>reallyBigImageTwo.jpg</tt> completes.
12.  <tt>body.onload()</tt> fires, in this case showing an alert() box.

This is a bit complex, but the point is to show exactly when various resources are fetched, and when <tt>onModuleLoad()</tt> will be called. The most important things to
remember are that

*   You want to put the GWT selection script as early as possible within the body, so that it begins fetching the compiled script before other scripts (because it won't block any
other script requests).
*   If you are going to be fetching external images and scripts, you want to manage your two connections carefully.
*   <tt>&lt;img&gt;</tt> tags are not guaranteed to be done loading when <tt>onModuleLoad()</tt> is called.
*   <tt>&lt;script&gt;</tt> tags **are** guaranteed to be done loading when <tt>onModuleLoad()</tt> is called.

### A Note on Multiple GWT Modules and EntryPoints

If you have multiple EntryPoints (the interface that defines <tt>onModuleLoad()</tt>) within a module, they will all be called in sequence as soon as that module (and the outer
document) is ready.

If you are loading multiple GWT modules within the same page, each module's EntryPoint will be called as soon as both that module and the outer document is ready. Two modules'
EntryPoints are not guaranteed to fire at the same time, or in the same order in which their selection scripts were specified in the host page.
